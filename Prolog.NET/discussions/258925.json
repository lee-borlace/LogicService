[
  {
    "Id": "617912",
    "ThreadId": "258925",
    "Html": "\r\n<p>Hi, I''ve got an algorithm written in swi prolog, working; wen I try to execute the algorithm in prolog.net it always fails, so I have some question: how could I retrieve errore messages form prolog compiler? How could use the &quot;trace&quot; in prolog.net? It is\r\n so diffrent prolog.net dialet from swi prolog?</p>\r\n<p>&nbsp;</p>\r\n<p>this is my swi-prolog code:</p>\r\n<p>&nbsp;</p>\r\n<pre>tile(1,y,y,b,r,b,r).\r\ntile(2,r,r,b,y,y,b).\r\ntile(3,b,b,y,y,r,r).\r\ntile(4,b,r,y,b,y,r).\r\ntile(5,b,b,r,y,y,r).\r\ntile(6,y,b,r,y,r,b).\r\ntile(7,b,b,y,r,y,r).\r\ntile(8,b,b,r,y,r,y).\r\ntile(9,r,b,y,r,y,b).\r\ntile(10,y,y,r,b,r,b).\r\ntile(11,r,r,b,y,b,y).\r\ntile(12,r,r,y,b,y,b).\r\ntile(13,b,b,y,r,r,y).\r\ntile(14,b,b,r,r,y,y).\r\ntile(15,g,g,r,y,y,r).\r\ntile(16,g,g,y,r,r,y).\r\ntile(17,y,y,g,r,g,r).\r\ntile(18,y,y,r,g,r,g).\r\ntile(19,r,r,g,y,g,y).\r\ntile(20,r,r,y,g,y,g).\r\ntile(21,g,g,r,r,y,y).\r\ntile(22,r,r,g,y,y,g).\r\ntile(23,g,g,y,y,r,r).\r\ntile(24,g,g,b,r,r,b).\r\ntile(25,b,b,g,g,r,r).\r\ntile(26,b,b,g,r,r,g).\r\ntile(27,r,r,b,g,b,g).\r\ntile(28,b,b,r,r,g,g).\r\ntile(29,r,r,g,b,g,b).\r\ntile(30,b,b,r,g,g,r).\r\ntile(31,g,g,r,y,r,y).\r\ntile(32,g,r,y,g,y,r).\r\ntile(33,g,g,y,r,y,r).\r\ntile(34,r,g,y,r,y,g).\r\ntile(35,y,g,r,y,r,g).\r\ntile(36,g,g,r,b,r,b).\r\ntile(37,b,b,g,r,g,r).\r\ntile(38,b,b,r,g,r,g).\r\ntile(39,g,b,r,g,r,b).\r\ntile(40,b,g,r,b,r,g).\r\ntile(41,g,g,b,r,b,r).\r\ntile(42,r,b,g,r,g,b).\r\ntile(43,b,b,y,y,g,g).\r\ntile(44,y,b,g,y,g,b).\r\ntile(45,b,b,g,g,y,y).\r\ntile(46,g,g,b,y,b,y).\r\ntile(47,b,b,y,g,g,y).\r\ntile(48,g,g,b,y,y,b).\r\ntile(49,b,b,g,y,y,g).\r\ntile(50,b,g,y,b,y,g).\r\ntile(51,g,b,y,g,y,b).\r\ntile(52,g,g,y,b,y,b).\r\ntile(53,y,y,g,b,g,b).\r\ntile(54,y,y,b,g,b,g).\r\ntile(55,b,b,g,y,g,y).\r\ntile(56,b,b,y,g,y,g).\r\n\r\n%avvio del programma, max 56 pedine, Rotazione rapp la rotazione\r\n%iniziale, tile pedina colore avvia l'estrazione dei dati dal db e\r\n%tantrix avvia l'elaborazione per allineare le pedine secondo la regola\r\n%aurea.\r\n%Pedina e Rotazione finiscono in 2 liste che rispettivamente contengono\r\n%il numero della pedina e la rotazione associata\r\n%cos� da poter mostra la soluzione del domino successivamente.\r\n%Mancano � un contatore per fermare l'esecuzione, indica le\r\n%pedine che mancano alla fine\r\n%Pedina rappresenta id iniziale delle pedine e Colore il colore\r\n%richiesto per l'inizio della sequenza (faccia alto dx)\r\ntantrix_d(Pezzi) :- Pezzi&lt;57, Mancano is Pezzi-1, Rotazione is 0,  tile(Pedina,Colore,_,_,_,_,_), domino(Colore,Mancano,[Pedina],[Rotazione]).\r\n\r\n\r\n%qui termina la ricorsione, mancano = 0\r\n%mostro a video la soluzione\r\ndomino(_,0,Pedine,Rotazioni) :- mostra_sln(Pedine,Rotazioni). %ribalto prima di stampare????? SOSPESO\r\n\r\n\r\n%Prima regola della ricorsione,\r\n%Colore � il colore richiesto, Mancano numero di pedine\r\n%che Mancano, Pedine lista con le pedine e Rotazioni sono le rotazioni.\r\n%ColSuccessivo � il prossimo colore da utilizzare per la base\r\n%della regola del domino\r\n%questa regola estrae la pedina non presente che combacia col\r\n%colore richiesto\r\n%\r\ndomino(Colore,Mancano,Pedine,Rotazioni) :- tile(ID,ColSuccessivo,_,_,Colore,_,_),not(presente(ID,Pedine)),Rotazione is 0,Mancano1 is Mancano-1, accoda(Pedine,[ID],Pedine1), accoda(Rotazioni,[Rotazione],Rotazioni1), domino(ColSuccessivo,Mancano1,Pedine1,Rotazioni1).\r\n\r\ndomino(Colore,Mancano,Pedine,Rotazioni) :- tile(ID,_,_,Colore,_,_,ColSuccessivo),not(presente(ID,Pedine)),Rotazione is 60,Mancano1 is Mancano-1, accoda(Pedine,[ID], Pedine1), accoda(Rotazioni,[Rotazione],Rotazioni1), domino(ColSuccessivo,Mancano1,Pedine1,Rotazioni1).\r\n\r\ndomino(Colore,Mancano,Pedine,Rotazioni) :- tile(ID,_,Colore,_,_,ColSuccessivo,_),not(presente(ID,Pedine)),Rotazione is 120,Mancano1 is Mancano-1, accoda(Pedine,[ID],Pedine1), accoda(Rotazioni,[Rotazione],Rotazioni1), domino(ColSuccessivo,Mancano1,Pedine1,Rotazioni1).\r\n\r\ndomino(Colore,Mancano,Pedine,Rotazioni) :- tile(ID,Colore,_,_,ColSuccessivo,_,_),not(presente(ID,Pedine)),Rotazione is 180,Mancano1 is Mancano-1, accoda(Pedine,[ID],Pedine1), accoda(Rotazioni,[Rotazione],Rotazioni1), domino(ColSuccessivo,Mancano1,Pedine1,Rotazioni1).\r\n\r\ndomino(Colore,Mancano,Pedine,Rotazioni) :- tile(ID,_,_,ColSuccessivo,_,_,Colore),not(presente(ID,Pedine)),Rotazione is 240,Mancano1 is Mancano-1, accoda(Pedine,[ID], Pedine1), accoda(Rotazioni,[Rotazione],Rotazioni1), domino(ColSuccessivo,Mancano1,Pedine1,Rotazioni1).\r\n\r\ndomino(Colore,Mancano,Pedine,Rotazioni) :- tile(ID,_,ColSuccessivo,_,_,Colore,_),not(presente(ID,Pedine)),Rotazione is 300,Mancano1 is Mancano-1, accoda(Pedine,[ID],Pedine1), accoda(Rotazioni,[Rotazione],Rotazioni1), domino(ColSuccessivo,Mancano1,Pedine1,Rotazioni1).\r\n\r\n\r\n\r\n%------------------Funzioni standard di elaborazione liste\r\n\r\n%Accoda il valore alla lista, usato\r\n%per aggiungere pedine e rotazioni\r\n%alle rispettive liste\r\n% accoda(X,L,[X|L]). %NO!!!!!!\r\n%trovo il modo di accodare\r\n% veramente o ribalto prima di stampare. SOSPESO\r\n\r\naccoda([], L, L).\r\naccoda([X|L1], L2, [X|L3]) :- accoda(L1, L2, L3).\r\n\r\n\r\n\r\n%Usato per controllare se l'id della pedina che sto\r\n%analizzando � gi� stata usata e quindi presente\r\n%nella lista delle pedine che formano la soluzione\r\n%del domino\r\npresente(ID,[ID|_]).\r\npresente(ID,[_|Ys]) :- presente(ID, Ys).\r\n\r\n%Mostra la soluzione a video\r\n%la soluzione � presente nelle 2 liste\r\n%In pratica smonto le liste e le mostro finch� non\r\n%sono vuote\r\nmostra_sln([],[]).\r\nmostra_sln(Pedine,Rotazione) :- smonta(Pedine,Pedine1,IDPedina),smonta(Rotazione,Rotazione1,ValRot),write('id: '),write(IDPedina),tab(2),write('posizione '),write(ValRot),write('�'), nl,mostra_sln(Pedine1,Rotazione1).\r\n\r\n%cancella la testa della lista, cos� fermo la stampa\r\nsmonta([T|C],C,T).\r\n</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>and this is my c# code:</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>Prolog.Program program = <span style=\"color:blue\">new</span> Prolog.Program();\r\n\r\n                <span style=\"color:blue\">string</span> path = <span style=\"color:#a31515\">@&quot;D:\\UNI\\Languages\\domino_dimasi.pl&quot;</span>;\r\n                <span style=\"color:blue\">byte</span>[] buffer= <span style=\"color:blue\">new</span> <span style=\"color:blue\">byte</span>[0];\r\n                <span style=\"color:blue\">using</span> (FileStream fs = <span style=\"color:blue\">new</span> FileStream(path, FileMode.Open))\r\n                {\r\n                    buffer = <span style=\"color:blue\">new</span> <span style=\"color:blue\">byte</span>[fs.Length];\r\n                    fs.Read(buffer, 0, buffer.Length);\r\n                }\r\n                <span style=\"color:blue\">string</span> prolog = Encoding.ASCII.GetString(buffer);\r\n                \r\n\r\n\r\n                \r\n                <span style=\"color:blue\">foreach</span> (CodeSentence codeSentence <span style=\"color:blue\">in</span> Parser.Parse(prolog))\r\n                    program.Add(codeSentence);\r\n\r\n                ExecutionResults risultato = ExecutionResults.None;\r\n\r\n                \r\n                <span style=\"color:blue\">foreach</span> (CodeSentence codeSentence <span style=\"color:blue\">in</span> Parser.Parse(<span style=\"color:#a31515\">&quot;:-tantrix_d(8).&quot;</span>))\r\n                {\r\n                    PrologMachine machine = PrologMachine.Create(program, <span style=\"color:blue\">new</span> Query(codeSentence));\r\n                    machine.ExecutionComplete &#43;= <span style=\"color:blue\">new</span> EventHandler&lt;PrologQueryEventArgs&gt;(machine_ExecutionComplete);\r\n                    machine.ExecutionSuspended &#43;= <span style=\"color:blue\">new</span> EventHandler(machine_ExecutionSuspended);\r\n                    risultato = machine.RunToBacktrack();\r\n                    <span style=\"color:blue\">if</span> (risultato == ExecutionResults.Success)\r\n                    {\r\n                        <span style=\"color:blue\">foreach</span> (PrologVariable v <span style=\"color:blue\">in</span> machine.QueryResults.Variables)\r\n                            Console.WriteLine(v);\r\n                    }\r\n                    <span style=\"color:blue\">else</span>\r\n                    {\r\n                        Console.WriteLine(<span style=\"color:#a31515\">&quot;FAIL!!!!!!!! &quot;</span>);                      \r\n                    }\r\n                }\r\n            }\r\n            <span style=\"color:blue\">catch</span> (Exception s)\r\n            {\r\n                Console.WriteLine(s.Message);\r\n            }\r\n\r\n\r\n            Console.ReadLine();\r\n</pre>\r\n</div>\r\n<p></p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>Thanks.</p>\r\n<p>Alex</p>\r\n",
    "PostedDate": "2011-05-25T02:46:28.763-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "618075",
    "ThreadId": "258925",
    "Html": "<p>I've find the error: I use the \"write('id: ')\" statement, that display a string as output, how I can translate it for using with prolog.net?</p>",
    "PostedDate": "2011-05-25T07:47:43.697-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "710586",
    "ThreadId": "258925",
    "Html": "This discussion has been copied to a work item. Click <a href=\"http://prolog.codeplex.com/workitem/7534\">here</a> to go to the work item and continue the discussion.",
    "PostedDate": "2011-12-11T12:19:15.813-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]