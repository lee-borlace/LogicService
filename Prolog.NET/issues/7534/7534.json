{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "",
    "ClosedDate": null,
    "CommentCount": 0,
    "Custom": null,
    "Description": "Hi, I''ve got an algorithm written in swi prolog, working; wen I try to execute the algorithm in prolog.net it always fails, so I have some question: how could I retrieve errore messages form prolog compiler? How could use the \"trace\" in prolog.net? It is\n so diffrent prolog.net dialet from swi prolog?\n \n \n \nthis is my swi-prolog code:\n \n \n \ntile(1,y,y,b,r,b,r).\ntile(2,r,r,b,y,y,b).\ntile(3,b,b,y,y,r,r).\ntile(4,b,r,y,b,y,r).\ntile(5,b,b,r,y,y,r).\ntile(6,y,b,r,y,r,b).\ntile(7,b,b,y,r,y,r).\ntile(8,b,b,r,y,r,y).\ntile(9,r,b,y,r,y,b).\ntile(10,y,y,r,b,r,b).\ntile(11,r,r,b,y,b,y).\ntile(12,r,r,y,b,y,b).\ntile(13,b,b,y,r,r,y).\ntile(14,b,b,r,r,y,y).\ntile(15,g,g,r,y,y,r).\ntile(16,g,g,y,r,r,y).\ntile(17,y,y,g,r,g,r).\ntile(18,y,y,r,g,r,g).\ntile(19,r,r,g,y,g,y).\ntile(20,r,r,y,g,y,g).\ntile(21,g,g,r,r,y,y).\ntile(22,r,r,g,y,y,g).\ntile(23,g,g,y,y,r,r).\ntile(24,g,g,b,r,r,b).\ntile(25,b,b,g,g,r,r).\ntile(26,b,b,g,r,r,g).\ntile(27,r,r,b,g,b,g).\ntile(28,b,b,r,r,g,g).\ntile(29,r,r,g,b,g,b).\ntile(30,b,b,r,g,g,r).\ntile(31,g,g,r,y,r,y).\ntile(32,g,r,y,g,y,r).\ntile(33,g,g,y,r,y,r).\ntile(34,r,g,y,r,y,g).\ntile(35,y,g,r,y,r,g).\ntile(36,g,g,r,b,r,b).\ntile(37,b,b,g,r,g,r).\ntile(38,b,b,r,g,r,g).\ntile(39,g,b,r,g,r,b).\ntile(40,b,g,r,b,r,g).\ntile(41,g,g,b,r,b,r).\ntile(42,r,b,g,r,g,b).\ntile(43,b,b,y,y,g,g).\ntile(44,y,b,g,y,g,b).\ntile(45,b,b,g,g,y,y).\ntile(46,g,g,b,y,b,y).\ntile(47,b,b,y,g,g,y).\ntile(48,g,g,b,y,y,b).\ntile(49,b,b,g,y,y,g).\ntile(50,b,g,y,b,y,g).\ntile(51,g,b,y,g,y,b).\ntile(52,g,g,y,b,y,b).\ntile(53,y,y,g,b,g,b).\ntile(54,y,y,b,g,b,g).\ntile(55,b,b,g,y,g,y).\ntile(56,b,b,y,g,y,g).\n \n%avvio del programma, max 56 pedine, Rotazione rapp la rotazione\n%iniziale, tile pedina colore avvia l'estrazione dei dati dal db e\n%tantrix avvia l'elaborazione per allineare le pedine secondo la regola\n%aurea.\n%Pedina e Rotazione finiscono in 2 liste che rispettivamente contengono\n%il numero della pedina e la rotazione associata\n%cos� da poter mostra la soluzione del domino successivamente.\n%Mancano � un contatore per fermare l'esecuzione, indica le\n%pedine che mancano alla fine\n%Pedina rappresenta id iniziale delle pedine e Colore il colore\n%richiesto per l'inizio della sequenza (faccia alto dx)\ntantrix_d(Pezzi) :- Pezzi<57, Mancano is Pezzi-1, Rotazione is 0,  tile(Pedina,Colore,_,_,_,_,_), domino(Colore,Mancano,[Pedina],[Rotazione]).\n \n \n%qui termina la ricorsione, mancano = 0\n%mostro a video la soluzione\ndomino(_,0,Pedine,Rotazioni) :- mostra_sln(Pedine,Rotazioni). %ribalto prima di stampare????? SOSPESO\n \n \n%Prima regola della ricorsione,\n%Colore � il colore richiesto, Mancano numero di pedine\n%che Mancano, Pedine lista con le pedine e Rotazioni sono le rotazioni.\n%ColSuccessivo � il prossimo colore da utilizzare per la base\n%della regola del domino\n%questa regola estrae la pedina non presente che combacia col\n%colore richiesto\n%\ndomino(Colore,Mancano,Pedine,Rotazioni) :- tile(ID,ColSuccessivo,_,_,Colore,_,_),not(presente(ID,Pedine)),Rotazione is 0,Mancano1 is Mancano-1, accoda(Pedine,[ID],Pedine1), accoda(Rotazioni,[Rotazione],Rotazioni1), domino(ColSuccessivo,Mancano1,Pedine1,Rotazioni1).\n \ndomino(Colore,Mancano,Pedine,Rotazioni) :- tile(ID,_,_,Colore,_,_,ColSuccessivo),not(presente(ID,Pedine)),Rotazione is 60,Mancano1 is Mancano-1, accoda(Pedine,[ID], Pedine1), accoda(Rotazioni,[Rotazione],Rotazioni1), domino(ColSuccessivo,Mancano1,Pedine1,Rotazioni1).\n \ndomino(Colore,Mancano,Pedine,Rotazioni) :- tile(ID,_,Colore,_,_,ColSuccessivo,_),not(presente(ID,Pedine)),Rotazione is 120,Mancano1 is Mancano-1, accoda(Pedine,[ID],Pedine1), accoda(Rotazioni,[Rotazione],Rotazioni1), domino(ColSuccessivo,Mancano1,Pedine1,Rotazioni1).\n \ndomino(Colore,Mancano,Pedine,Rotazioni) :- tile(ID,Colore,_,_,ColSuccessivo,_,_),not(presente(ID,Pedine)),Rotazione is 180,Mancano1 is Mancano-1, accoda(Pedine,[ID],Pedine1), accoda(Rotazioni,[Rotazione],Rotazioni1), domino(ColSuccessivo,Mancano1,Pedine1,Rotazioni1).\n \ndomino(Colore,Mancano,Pedine,Rotazioni) :- tile(ID,_,_,ColSuccessivo,_,_,Colore),not(presente(ID,Pedine)),Rotazione is 240,Mancano1 is Mancano-1, accoda(Pedine,[ID], Pedine1), accoda(Rotazioni,[Rotazione],Rotazioni1), domino(ColSuccessivo,Mancano1,Pedine1,Rotazioni1).\n \ndomino(Colore,Mancano,Pedine,Rotazioni) :- tile(ID,_,ColSuccessivo,_,_,Colore,_),not(presente(ID,Pedine)),Rotazione is 300,Mancano1 is Mancano-1, accoda(Pedine,[ID],Pedine1), accoda(Rotazioni,[Rotazione],Rotazioni1), domino(ColSuccessivo,Mancano1,Pedine1,Rotazioni1).\n \n \n \n%------------------Funzioni standard di elaborazione liste\n \n%Accoda il valore alla lista, usato\n%per aggiungere pedine e rotazioni\n%alle rispettive liste\n% accoda(X,L,[X|L]). %NO!!!!!!\n%trovo il modo di accodare\n% veramente o ribalto prima di stampare. SOSPESO\n \naccoda([], L, L).\naccoda([X|L1], L2, [X|L3]) :- accoda(L1, L2, L3).\n \n \n \n%Usato per controllare se l'id della pedina che sto\n%analizzando � gi� stata usata e quindi presente\n%nella lista delle pedine che formano la soluzione\n%del domino\npresente(ID,[ID|_]).\npresente(ID,[_|Ys]) :- presente(ID, Ys).\n \n%Mostra la soluzione a video\n%la soluzione � presente nelle 2 liste\n%In pratica smonto le liste e le mostro finch� non\n%sono vuote\nmostra_sln([],[]).\nmostra_sln(Pedine,Rotazione) :- smonta(Pedine,Pedine1,IDPedina),smonta(Rotazione,Rotazione1,ValRot),write('id: '),write(IDPedina),tab(2),write('posizione '),write(ValRot),write('�'), nl,mostra_sln(Pedine1,Rotazione1).\n \n%cancella la testa della lista, cos� fermo la stampa\nsmonta([T|C],C,T).\n \n \n \n \n \nand this is my c# code:\n \n \n \n \nProlog.Program program = new Prolog.Program();\n \n                string path = @\"D:\\UNI\\Languages\\domino_dimasi.pl\";\n                byte[] buffer= new byte[0];\n                using (FileStream fs = new FileStream(path, FileMode.Open))\n                {\n                    buffer = new byte[fs.Length];\n                    fs.Read(buffer, 0, buffer.Length);\n                }\n                string prolog = Encoding.ASCII.GetString(buffer);\n                \n \n \n                \n                foreach (CodeSentence codeSentence in Parser.Parse(prolog))\n                    program.Add(codeSentence);\n \n                ExecutionResults risultato = ExecutionResults.None;\n \n                \n                foreach (CodeSentence codeSentence in Parser.Parse(\":-tantrix_d(8).\"))\n                {\n                    PrologMachine machine = PrologMachine.Create(program, new Query(codeSentence));\n                    machine.ExecutionComplete &#43;= new EventHandler<PrologQueryEventArgs>(machine_ExecutionComplete);\n                    machine.ExecutionSuspended &#43;= new EventHandler(machine_ExecutionSuspended);\n                    risultato = machine.RunToBacktrack();\n                    if (risultato == ExecutionResults.Success)\n                    {\n                        foreach (PrologVariable v in machine.QueryResults.Variables)\n                            Console.WriteLine(v);\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"FAIL!!!!!!!! \");                      \n                    }\n                }\n            }\n            catch (Exception s)\n            {\n                Console.WriteLine(s.Message);\n            }\n \n \n            Console.ReadLine();\n \n \n \n \n \n \n \n \nThanks.\n \nAlex",
    "LastUpdatedDate": "2013-02-13T17:42:15.083-08:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "Low",
      "Severity": 50,
      "Id": 1
    },
    "ProjectName": "prolog",
    "ReportedDate": "2011-12-11T12:19:14.303-08:00",
    "Status": {
      "Name": "Proposed",
      "Id": 1
    },
    "ReasonClosed": {
      "Name": "Unassigned"
    },
    "Summary": "Porting algorithm from swi prolog to Prolog.net",
    "Type": {
      "Name": "Issue",
      "Id": 3
    },
    "VoteCount": 1,
    "Id": 7534
  },
  "FileAttachments": [],
  "Comments": []
}